% load the matrix
% matrix from SuiteSparse
matnum = 'SiH4';
S = load([matnum '.mat']);
matrix = S.Problem.A;
n = size(matrix, 1);
% convert to function hand
A = @(x) matrix * x;

% matrix generated by function 'getStartMatrix'
%n = 2500;
%alpha = 0.5;
%matrix = getStartMatrix(n, alpha);
%matnum = 'genMatrix(1e-3)';
%A = matrix;

% set the basic parameters
b = randn(n,1);
b = b / norm(b);
% step size
ss = 5:5:50;
%ss = [50];
l = length(ss);
res4s = {};
ctol = 1e-16;
runs = 1;

% define AOB_options for RBGS
AOB_options = ["rCGS2", "rCGS", "RGS", "rMGS"];
% define WB_options for RBGS
WB_options = ["rCGS", "rCGS2", "RGS", "rMGS", "rWhitening"];
orth_option = [3, 2];

% define sketch methods
SketchMethods = {...
        %'Gaussian',    @Gaussian; ...        
        'CountSketch', @CountSketch; ...        
        %'Rademacher',  @Rademacher ...
        };


% ---------- GMRES matlab ----------
fprintf('Starting GMRES \n');Î©
[~,~,~,~,resvec] = gmres(A,b,[],ctol,1000);
fprintf('GMRES terminated \n');
% record the minimum relative residual achieved by GMRES
res4s{end + 1} = min(resvec); 


for j = 1:l
    s = ss(j);
    p = round(500/s);
    m = p * s + 1;
    d = 2 * m;

    % Generate the basis
    % Monomial Basis
    %basisFunc = @mpk;
    % Newton Basis
    RitzValues = getRitzValues(A, randn(n, 1), s);
    basisFunc = @(Afun, q, s) mpk(Afun, q, s, RitzValues);

    % ---------- RBGS ----------
    fprintf('Starting RBGS, s = %d \n', s);            
    % orthogonalized methods for RBGS
    AOB = AOB_options(orth_option(1));
    WB = WB_options(orth_option(2));

    % record the result for RBGS
    iters_RBGS = [];   % record the iteration number for each sketch method
                      % for a fixed s, runs * size(SketchMethods, 1)
    labels_RBGS = []; % runs * size(SketchMethods, 1)
    times_RBGS = [];   % record the time for each sketch method for a fixed
                      % s, runs * size(SketchMethods, 1) 
    relErr = {}; % record the relative residual of the selected
                      % sketch method in each run for a fixed s,
                      % length(beta_eachRun) * runs
    orthErr = {};% record the orthogonality loss of the selected
                      % sketch method in each run for a fixed s,
                      % length(orthErr_eachRun) * runs    
    for i = 1:size(SketchMethods, 1)
        name = SketchMethods{i, 1};
        iters = zeros(runs, 1);
        times = zeros(runs, 1);
        genTheta = SketchMethods{i, 2};
        for w = 1:runs
            Theta = genTheta(d, n);
            tic;
            [~, beta, orthError] = RBGS_GMRES(A, s, p, Theta, basisFunc, ...
                AOB, WB, b, ctol);
            times(w) = toc;
            iters(w) = length(beta) - 1;    
            if strcmp(name, 'CountSketch')
                relErr{end+1} = beta;
                orthErr{end+1} = orthError;
            end    
        end    
        %collect results
        iters_RBGS = [iters_RBGS; iters];
        times_RBGS = [times_RBGS; times];
        labels_RBGS = [labels_RBGS; repmat({name}, runs, 1)];
    end            
    fprintf('RBGS terminated \n');


    % ---------- BGS_GMRES ----------
    fprintf('Starting BGS, s = %d \n', s);
    tic;
    [~, relErr_BGS, orthErr_BGS] = BGS_GMRES0(A, s, p, basisFunc, "CGS", "CGS2", b, ctol);
    time_BGS = toc;
    iters_BGS = length(relErr_BGS) - 1;

    fprintf('BGS terminated \n');


    % compute the statistics for RBGS for plot

    % mean & 95% confidence interval for relErr
    % convert relErr to a matrix, pad the shorter vector with NaNs
    maxLen = max(cellfun(@length, relErr));
    relErr_RBGS = nan(runs, maxLen);
    for k = 1:runs
        relErr_RBGS(k,1:numel(relErr{k})) = relErr{k};
    end
    nEff = sum(~isnan(relErr_RBGS), 1); % 1-by-maxLen
    relErr_mean = nanmean(relErr_RBGS,1); % 1-by-maxLen
    relErr_std  = nanstd(relErr_RBGS,[],1); % 1-by-maxlen    
    % 95% confidence interval
    relErr_ci = 1.96 * relErr_std ./ sqrt(nEff);

    % mean & 95% confidence interval for orth
    maxLen_orth = max(cellfun(@length, orthErr));
    orthErr_RBGS = nan(runs, maxLen_orth);    
    for k = 1:runs
        orthErr_RBGS(k, 1:numel(orthErr{k})) = orthErr{k};
    end
    nEff_orth = sum(~isnan(orthErr_RBGS), 1); % 1-by-maxLen_orth
    orthErr_mean = nanmean(orthErr_RBGS, 1);
    orthErr_std  = nanstd(orthErr_RBGS, [], 1);    
    % 95% confidence interval
    orthErr_ci = 1.96 * orthErr_std ./ sqrt(nEff_orth);


    % record the minimum residual achieved for each s
    res4s{end + 1} = [min(relErr_mean(2:end)), min(relErr_BGS(2:end))];

    
    % ---------- plot for each s ----------
    % plot 1: relative error vs. iteration number
    figure; 
    hold on;

    % RBGS: hollow circles + vertical error bars
    h = errorbar(0:maxLen-1, relErr_mean, relErr_ci, 'o', ...
        'Color','k','MarkerSize',5,'LineWidth',1, ...
        'MarkerFaceColor','w', ...   % hollow circle
        'DisplayName','RBGS-GMRES');
    h.LineStyle = 'none';    % no connecting line
    % BGS
    semilogy(0:iters_BGS, relErr_BGS, 'r-^', 'LineWidth', 1, ...
        'DisplayName','BGS-GMRES');    
    % GMRES build-in
    semilogy(0:numel(resvec(1:s:end))-1,resvec(1:s:end), 'b-diamond', 'LineWidth', 1, ...
        'DisplayName','GMRES');
    
    xlabel('Iteration Number');
    ylabel('Relative Residual $\| A x - b \|_2 / \| b \|_2$', ...
            'Interpreter', 'latex', 'FontSize', 14);
    set(gca,'YScale','log');
    legend('show','Location','best');
    grid on;    
    title(sprintf('Relative Residual vs. Iteration Number (s = %d, m = %d, %s)', s, m, matnum));    
    exportgraphics(gcf, sprintf('fig/%s/%s_relErr_iter_CI_s%d_m%d_reorth_newton.png', matnum, matnum, s, m));


    % Plot 2: orthogonality loss
    figure; 
    hold on;

    
    % RBGS: hollow circles + vertical error bars
    h = errorbar(0:maxLen_orth-1, orthErr_mean, orthErr_ci, 'o', ...
        'Color','k','MarkerSize',5,'LineWidth',1.2, ...
        'MarkerFaceColor','w', ...
        'DisplayName','RBGS-GMRES');
    h.LineStyle = 'none';    % no connecting line    
    % BGS
    semilogy(0:iters_BGS, orthErr_BGS, 'r-^', 'LineWidth', 1.5, ...
        'DisplayName','BGS-GMRES');
    
    xlabel('Iteration Number');
    ylabel('Orthogonality loss $\|\mathbf{Q}^\top \mathbf{Q} - \mathbf{I}\|_F$', ...
           'Interpreter', 'latex', 'FontSize', 14);
    set(gca,'YScale','log');
    legend('show','Location','best');
    grid on;    
    title(sprintf('Orthogonality loss vs. Iteration Number (s = %d, m = %d, %s)', s, m, matnum));
    exportgraphics(gcf, sprintf('fig/%s/%s_orthErr_s%d_m%d_reorth_newton.png', matnum, matnum, s, m));
    
    
    
    
    
    
    
        
    
    %plot 3: iteration numbers
    %figure;
    %boxplot(iters_RBGS, labels_RBGS);
    %ylabel('Iteration number');
    %title('Iteration numbers for different sketch methods');
    %grid on;
    
    %ymin = min([iters_RBGS(:); iters_BGS]) - 1;
    %ymax = max([iters_RBGS(:); iters_BGS]) + 1;
    %ylim([ymin, ymax]);
    
    %add horizontal line for BGS-GMRES
    %hold on;
    %yline(iters_BGS, 'r--', 'LineWidth', 1.5, ...
           %'Label', 'BGS_GMRES', 'LabelHorizontalAlignment', 'left');
    %hold off;
    %save plot
    %exportgraphics(gcf, 'fig/box_iter.eps', 'Resolution', 300);
    
    %plot 3: runtime
    %figure;
    %boxplot(times_RBGS, labels_RBGS);
    %ylabel('Runtime (seconds)');
    %title('Runtime for different sketch methods');
    %grid on;
    %add horizontal line for BGS_GMRES
    %hold on;
    %yline(time_BGS, 'r--', 'LineWidth', 1.5, ...
           %'Label', 'BGS_GMRES', 'LabelHorizontalAlignment', 'left');
    %hold off;
    %save plot
    %exportgraphics(gcf, 'fig/box_runtime.eps', 'Resolution', 300);
    
  
end

errs = cellfun(@(v) v(:).', res4s(2:end), 'UniformOutput', false);
errs = vertcat(errs{:});              % l-by-2
y0 = res4s{1};                         % GMRES

figure;
semilogy(ss, errs(:,1), '-o', 'LineWidth', 1.5, 'MarkerSize', 6, 'DisplayName', 'RBGS'); hold on;
semilogy(ss, errs(:,2), '-s', 'LineWidth', 1.5, 'MarkerSize', 6, 'DisplayName', 'BGS');
yline(y0, '--', 'LineWidth', 1.5, 'DisplayName', sprintf('Baseline = %.4g', y0));

grid on;
xlabel('s');
ylabel('Relative Residual $\| A x - b \|_2 / \| b \|_2$', ...
            'Interpreter', 'latex', 'FontSize', 14);
title(sprintf('Minimum Relative Residual vs s (%s)', matnum));
legend('Location', 'best');
exportgraphics(gcf, sprintf('fig/%s/%s_minrel_s5-s50.png', matnum, matnum));