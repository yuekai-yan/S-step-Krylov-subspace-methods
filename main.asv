% load the matrix
% matrix from SuiteSparse
%matnum = 'SiO2';
%S = load([matnum '.mat']);
%matrix = S.Problem.A;
%n = size(matrix, 1);
% convert to function hand
%A = @(x) matrix * x;

% matrix generated by function 'getStartMatrix'
n = 5000;
alpha = 0.5;
matrix = getStartMatrix(n, alpha);
matnum = 'genMatrix(1e-3)';
A = matrix;

% set the basic parameters
rng(0);
t = randn(n,1);
b = A(t);
% step size
%ss = 5:5:50;
ss = 40;
l = length(ss);
res4s = {};
ctol = 1e-16;
runs = 1;

% define AOB_options for RBGS
AOB_options = ["rCGS2", "rCGS", "RGS", "rMGS"];
% define WB_options for RBGS
WB_options = ["rCGS", "rCGS2", "RGS", "rMGS", "rWhitening"];
orth_option = [4, 2];
% orthogonalized methods for RBGS
AOB = AOB_options(orth_option(1));
WB = WB_options(orth_option(2));

% define sketch methods
SketchMethods = {...
        %'Gaussian',    @Gaussian; ...        
        %'CountSketch', @CountSketch; ...        
        %'Rademacher',  @Rademacher ...
        'Sparsesign',  @sparsesign
        };

%{
% ---------- GMRES matlab ----------
fprintf('Starting GMRES \n');
[~,~,~,~,resvec] = gmres(A,b,[],ctol,1000);
fprintf('GMRES terminated \n');
% record the minimum relative residual achieved by GMRES
res4s{end + 1} = min(resvec);
%}

fig_rel = figure; 
hold on; 
grid on;
set(gca,'YScale','log');

%{
fig_orth = figure;
hold on; 
grid on;
set(gca,'YScale','log');
%}

fig_cond = figure; 
hold on; 
grid on;
set(gca,'YScale','log');

fig_sol = figure; 
hold on; 
grid on;
set(gca,'YScale','log');

markers = {'o','s','^','d','v','>','<','p'};

for j = 1:l
    s = ss(j);
    p = round(1000/s);
    m = p * s + 1;
    d = 2*m;
    mk = markers{j};

    % Generate the basis
    % Monomial Basis
    %basisFunc = @mpk;
    % Newton Basis
    RitzValues = getRitzValues(A, randn(n, 1), s);
    basisFunc = @(Afun, q, s) mpk(Afun, q, s, RitzValues);

    % ---------- RBGS ----------
    fprintf('Starting RBGS, s = %d \n', s);            

    % record the result for RBGS
    iters_RBGS = [];   % record the iteration number for each sketch method
                      % for a fixed s, runs * size(SketchMethods, 1)
    labels_RBGS = []; % runs * size(SketchMethods, 1)
    times_RBGS = [];   % record the time for each sketch method for a fixed
                      % s, runs * size(SketchMethods, 1) 
    relErr = {}; % record the relative residual of the selected
                      % sketch method in each run for a fixed s,
                      % length(beta_eachRun) * runs
    orthErr = {};% record the orthogonality loss of the selected
                      % sketch method in each run for a fixed s,
                      % length(orthErr_eachRun) * runs 
    cond_num = {};
    sol_ls = {};
    for i = 1:size(SketchMethods, 1)
        name = SketchMethods{i, 1};
        iters = zeros(runs, 1);
        times = zeros(runs, 1);
        genTheta = SketchMethods{i, 2};
        rng(20);
        for w = 1:runs
            if strcmp(name, 'Sparsesign')
                Theta = genTheta(d, n, 8);
            else
                Theta = genTheta(d, n);
            end
            tic;
            [sol, beta, orthError, c] = RBGS_GMRES(A, s, p, Theta, basisFunc, ...
                AOB, WB, b, ctol);
            times(w) = toc;
            iters(w) = length(beta) - 1;    
            if strcmp(name, 'Sparsesign')
                relErr{end+1} = beta;
                orthErr{end+1} = orthError;
                cond_num{end+1} = c;
                sol_ls{end+1} = vecnorm((sol-t)/norm(t), 2, 1).';
            end    
        end    
        %collect results
        iters_RBGS = [iters_RBGS; iters];
        times_RBGS = [times_RBGS; times];
        labels_RBGS = [labels_RBGS; repmat({name}, runs, 1)];
    end            
    fprintf('RBGS terminated \n');


    % ---------- BGS_GMRES ----------
    fprintf('Starting BGS, s = %d \n', s);
    tic;
    [solBGS, relErr_BGS, orthErr_BGS] = BGS_GMRES0(A, s, p, basisFunc, "MGS", "CGS2", b, ctol);
    sol_BGS = vecnorm((solBGS-t)/norm(t), 2, 1).';
    time_BGS = toc;
    iters_BGS = length(relErr_BGS) - 1;

    fprintf('BGS terminated \n');


    % compute the statistics for RBGS for plot

    % mean & 95% confidence interval for relErr
    % convert relErr to a matrix, pad the shorter vector with NaNs
    maxLen = max(cellfun(@length, relErr));
    relErr_RBGS = nan(runs, maxLen);
    for k = 1:runs
        relErr_RBGS(k,1:numel(relErr{k})) = relErr{k};
    end
    nEff = sum(~isnan(relErr_RBGS), 1); % 1-by-maxLen
    relErr_mean = nanmean(relErr_RBGS,1); % 1-by-maxLen
    relErr_std  = nanstd(relErr_RBGS,[],1); % 1-by-maxlen    
    % 95% confidence interval
    relErr_ci = 1.96 * relErr_std ./ sqrt(nEff);

    % mean & 95% confidence interval for orth
    maxLen_orth = max(cellfun(@length, orthErr));
    orthErr_RBGS = nan(runs, maxLen_orth);    
    for k = 1:runs
        orthErr_RBGS(k, 1:numel(orthErr{k})) = orthErr{k};
    end
    nEff_orth = sum(~isnan(orthErr_RBGS), 1); % 1-by-maxLen_orth
    orthErr_mean = nanmean(orthErr_RBGS, 1);
    orthErr_std  = nanstd(orthErr_RBGS, [], 1);    
    % 95% confidence interval
    orthErr_ci = 1.96 * orthErr_std ./ sqrt(nEff_orth);

    % mean & 95% confidence interval for cond
    maxLen_cond = max(cellfun(@length, cond_num));
    cond_RBGS = nan(runs, maxLen_cond);    
    for k = 1:runs
        cond_RBGS(k, 1:numel(cond_num{k})) = cond_num{k};
    end
    nEff_cond = sum(~isnan(cond_RBGS), 1); % 1-by-maxLen_cond
    cond_mean = nanmean(cond_RBGS, 1);
    cond_std  = nanstd(cond_RBGS, [], 1);    
    % 95% confidence interval
    cond_ci = 1.96 * cond_std ./ sqrt(nEff_cond);

    % mean & 95% confidence interval for relative error
    sol_RBGS = nan(runs, n);    
    for k = 1:runs
        sol_RBGS(k, 1:numel(sol_ls{k})) = sol_ls{k};
    end
    nEff_sol = sum(~isnan(sol_RBGS), 1); 
    sol_mean = nanmean(sol_RBGS, 1);
    sol_std  = nanstd(sol_RBGS, [], 1);    
    % 95% confidence interval
    sol_ci = 1.96 * sol_std ./ sqrt(nEff_sol);



    % record the minimum residual achieved for each s
    res4s{end + 1} = [min(relErr_mean(2:end)), min(relErr_BGS(2:end))];

    
    % ---------- plot for each s ----------
    % plot 1: relative residual
    figure(fig_rel);
    % RBGS: hollow circles + vertical error bars
    h = errorbar(0:s:s*(maxLen-1), relErr_mean, relErr_ci, mk, ...
        'Color','k','MarkerSize',5,'LineWidth',1, ...
        'MarkerFaceColor','w', ...   % hollow circle
        'DisplayName',sprintf('RBGS-GMRES, s = %d', s));
    h.LineStyle = 'none';    % no connecting line
    % BGS
    semilogy(0:s:s*iters_BGS, relErr_BGS, 'Color', 'r', 'Marker', mk, 'LineWidth', 1, ...
        'DisplayName',sprintf('BGS-GMRES, s = %d', s));

    %{
    % GMRES build-in
    semilogy(0:s:s*(numel(resvec(1:s:end))-1),resvec(1:s:end) / norm(b), 'b-diamond', 'LineWidth', 1, ...
        'DisplayName','GMRES');
    %}
    
    
    %{
    % Plot 2: orthogonality loss
    figure(fig_orth);
    % RBGS: hollow circles + vertical error bars
    h = errorbar(0:s:s*(maxLen_orth-1), orthErr_mean, orthErr_ci, mk, ...
        'Color','k','MarkerSize',5,'LineWidth',1.2, ...
        'MarkerFaceColor','w', ...
        'DisplayName',sprintf('RBGS-GMRES, s = %d', s));
    h.LineStyle = 'none';    % no connecting line    
    % BGS
    semilogy(0:s:s*iters_BGS, orthErr_BGS, 'Color', 'r', 'Marker', mk, 'LineWidth', 1.5, ...
        'DisplayName',sprintf('BGS-GMRES, s = %d', s));
    %}

    % Plot 3: condition number
    figure(fig_cond);
    % RBGS: hollow circles + vertical error bars
    h = errorbar(0:s:s*(maxLen_cond-1), cond_mean, cond_ci, mk, ...
        'Color','k','MarkerSize',5,'LineWidth',1.2, ...
        'MarkerFaceColor','w', ...
        'DisplayName',sprintf('RBGS-GMRES, s = %d', s));
    h.LineStyle = 'none';    % no connecting line 

    % Plot 4: relative error
    figure(fig_sol);
    % RBGS: hollow circles + vertical error bars
    h = errorbar(0:s:s*(n-1), sol_mean, sol_ci, mk, ...
        'Color','k','MarkerSize',5,'LineWidth',1.2, ...
        'MarkerFaceColor','w', ...
        'DisplayName',sprintf('RBGS-GMRES, s = %d', s));
    h.LineStyle = 'none';    % no connecting line 
    % BGS
    semilogy(0:s:s*iters_BGS, sol_BGS, 'Color', 'r', 'Marker', mk, 'LineWidth', 1, ...
        'DisplayName',sprintf('BGS-GMRES, s = %d', s));
    
    
    
            
    %{
    % plot 3: iteration numbers
    figure;
    boxplot(iters_RBGS, labels_RBGS);
    ylabel('Iteration number');
    title('Iteration numbers for different sketch methods');
    grid on;    
    ymin = min([iters_RBGS(:); iters_BGS]) - 1;
    ymax = max([iters_RBGS(:); iters_BGS]) + 1;
    ylim([ymin, ymax]);    
    add horizontal line for BGS-GMRES
    hold on;
    yline(iters_BGS, 'r--', 'LineWidth', 1.5, ...
           'Label', 'BGS_GMRES', 'LabelHorizontalAlignment', 'left');
    hold off;
    exportgraphics(gcf, 'fig/box_iter.eps', 'Resolution', 300);
    
    % plot 3: runtime
    figure;
    boxplot(times_RBGS, labels_RBGS);
    ylabel('Runtime (seconds)');
    title('Runtime for different sketch methods');
    grid on;
    % add horizontal line for BGS_GMRES
    hold on;
    yline(time_BGS, 'r--', 'LineWidth', 1.5, ...
           'Label', 'BGS_GMRES', 'LabelHorizontalAlignment', 'left');
    hold off;
    save plot
    exportgraphics(gcf, 'fig/box_runtime.eps', 'Resolution', 300);
    %}
  
end

figure(fig_rel);
xlabel('Iteration Number');
ylabel('Relative Residual $\| A x - b \|_2 / \| b \|_2$', ...
        'Interpreter', 'latex', 'FontSize', 14);
legend('show','Location','best');   
title(sprintf('Relative Residual vs. Iteration Number (m ≈ %d, %s, AOB=%s, WB=%s)', m, matnum, AOB, WB));    
%exportgraphics(gcf, sprintf('fig/%s/%s_relErr_m501_%s_%s.png', matnum, matnum, AOB, WB));

%{
figure(fig_orth);
xlabel('Iteration Number');
ylabel('Orthogonality loss $\|\mathbf{Q}^\top \mathbf{Q} - \mathbf{I}\|_F$', ...
       'Interpreter', 'latex', 'FontSize', 14);
legend('show','Location','best');   
title(sprintf('Orthogonality loss vs. Iteration Number (m ≈ , %s)', matnum));
%exportgraphics(gcf, sprintf('fig/%s/%s_orthErr_m501_%s_%s.png', matnum, matnum, AOB, WB));
%}    

figure(fig_cond);
xlabel('Iteration Number');
ylabel('Condition number of $\Theta$-orthonormal matrix Q', ...
        'Interpreter', 'latex', 'FontSize', 14);
legend('show','Location','best');   
title(sprintf('Condition number vs. Iteration Number (m ≈ %d, %s, AOB=%s, WB=%s)', m, matnum, AOB, WB));    


figure(fig_sol);
xlabel('Iteration Number');
ylabel('Relative Error $\| x - t \|_2 / \| t \|_2$', ...
        'Interpreter', 'latex', 'FontSize', 14);
legend('show','Location','best');   
title(sprintf('Relative error vs. Iteration Number (m ≈ %d, %s, AOB=%s, WB=%s)', m, matnum, AOB, WB));    


%{
errs = cellfun(@(v) v(:).', res4s, 'UniformOutput', false);
errs = vertcat(errs{:});              % l-by-2
%y0 = res4s{1};                         % GMRES

figure;
semilogy(ss, errs(:,1), '-o', 'LineWidth', 1.5, 'MarkerSize', 6, 'DisplayName', 'RBGS'); 
hold on;
semilogy(ss, errs(:,2), '-s', 'LineWidth', 1.5, 'MarkerSize', 6, 'DisplayName', 'BGS');
% Baseline for GMRES built-in
%yline(y0, '--', 'LineWidth', 1.5, 'DisplayName', sprintf('Baseline = %.4g', y0));
grid on;
xlabel('s');
ylabel('Relative Residual $\| A x - b \|_2 / \| b \|_2$', ...
            'Interpreter', 'latex', 'FontSize', 14);
title(sprintf('Minimum Relative Residual vs s (%s)', matnum));
legend('Location', 'best');
%exportgraphics(gcf, sprintf('fig/%s/%s_minrel_s5-s50.png', matnum, matnum));
%}