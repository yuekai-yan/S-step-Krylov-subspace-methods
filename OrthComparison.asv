rng(0);
% load the matrix
% matrix from SuiteSparse
matnum = 'SiO2';
S = load([matnum '.mat']);
matrix = S.Problem.A;
n = size(matrix, 1);
% convert to function handle
A = @(x) matrix * x;

% matrix generated by function 'getStartMatrix'
%n = 5000;
%alpha = 0.5;
%matrix = getStartMatrix(n, alpha);
%matnum = 'genMatrix(1e-3)';
%A = matrix;

% set the basic parameters
t = randn(n,1);
b = A(t);
% step size
ss = 3040;
l = length(ss);
%s = 5;

ctol = 1e-16;
runs = 1;

% define AOB_options for RBGS
%AOB_options = ["rCGS2", "rCGS", "RGS", "rMGS"];
AOB_options = ["rCGS", "RGS", "rMGS"];
%AOB_options = ["rCGS2"];
% define WB_options for RBGS
%WB_options = ["rCGS", "rCGS2", "RGS", "rMGS", "rWhitening"];
WB_options = ["rCGS", "rCGS2"];
%WB_options = ["rCGS"];

relErr = zeros(length(WB_options),length(AOB_options), l);
orthErr = zeros(length(WB_options),length(AOB_options), l);

idx_ls = zeros(length(WB_options),length(AOB_options), l);
cond_ls = zeros(length(WB_options),length(AOB_options), l);
sol_ls = zeros(length(WB_options),length(AOB_options), l);
for vs = 1:l
    s = ss(vs);
    p = round(1000/s);
    m = p * s + 1;
    d = 2 * m;
    % Newton Basis
    RitzValues = getRitzValues(A, randn(n, 1), s);
    basisFunc = @(Afun, q, s) mpk(Afun, q, s, RitzValues);
    % Monomial Basis    
    %basisFunc = @mpk;
    Theta = sparsesign(d, n, 8);
    for aob = 1:length(AOB_options)
        for wb = 1:length(WB_options)
            % orthogonalized methods for RBGS
            orth_option = [aob, wb];
            AOB = AOB_options(orth_option(1));
            WB = WB_options(orth_option(2));
            fprintf('Starting AOB = %s, WB = %s, s = %d \n', AOB, WB, s);
            
            % record the result for RBGS
            iters_RBGS = [];   % record the iteration number 
            relErr0 = {};   % record the relative residual in each run
                           % length(beta_eachRun) * runs
            orthErr0 = {};  % record the orthogonality loss in each run
                           % length(orthErr_eachRun) * runs        
            iters = zeros(runs, 1);      
            for w = 1:runs
                [sol, beta, orthError, cond_num] = RBGS_GMRES(A, s, p, Theta, basisFunc, ...
                    AOB, WB, b, ctol);
                iters(w) = length(beta) - 1;             
                relErr0{end+1} = beta;
                orthErr0{end+1} = orthError;                
            end    
            %collect results
            iters_RBGS = [iters_RBGS; iters];
            
            % compute the statistics for RBGS for plot        
            % mean for relErr
            % convert relErr to a matrix, pad the shorter vector with NaNs
            maxLen = max(cellfun(@length, relErr0));
            relErr_RBGS = nan(runs, maxLen);
            for k = 1:runs
                relErr_RBGS(k,1:numel(relErr0{k})) = relErr0{k};
            end
            relErr_mean = nanmean(relErr_RBGS,1); % 1-by-maxLen
            
            
            % mean for orth
            maxLen_orth = max(cellfun(@length, orthErr0));
            orthErr_RBGS = nan(runs, maxLen_orth);    
            for k = 1:runs
                orthErr_RBGS(k, 1:numel(orthErr0{k})) = orthErr0{k};
            end
            orthErr_mean = nanmean(orthErr_RBGS, 1);
    
            % collect the result for each combination (aob, wb)
            %[relErr(wb, aob), idx] = min(relErr_mean(2:end));
            %orthErr(wb, aob) = orthErr_mean(idx);
            % use elbow point detection instead of min(relErr)
            y = log10(relErr_mean(:));               
            valid = isfinite(y);  % remove NaN or Inf entries
            x = (1:numel(y))';
            x = x(valid);  y = y(valid);        
            % line through the first and last points
            p1 = [x(1), y(1)]; 
            p2 = [x(end), y(end)];        
            % perpendicular distance to the endpoint line
            dist = abs((p2(2)-p1(2))*x - (p2(1)-p1(1))*y + p2(1)*p1(2) - p2(2)*p1(1)) ...
                   / hypot(p2(2)-p1(2), p2(1)-p1(1));                                 
            % record relErr and orthErr at the elbow point
            [~, idx] = max(dist);
            %[~, idx] = min(relErr_mean);
            relErr(wb, aob, vs)  = relErr_mean(idx);
            orthErr(wb, aob, vs) = orthErr_mean(idx);
            idx_ls(wb, aob, vs) = idx * s;
            cond_ls(wb, aob, vs) = cond_num(idx);
            sol_ls(wb, aob, vs) = norm(sol(:, idx)-t) / norm(t);
        end
    end
end
% ---------- plot ----------

%{
% plot for relErr
R = log10(relErr);                

figure;
imagesc(R);  
colormap(parula);
caxis([-16 0]); 
colorbar;

set(gca,'XTick',1:length(AOB_options),'XTickLabel',AOB_options);
set(gca,'YTick',1:length(WB_options),'YTickLabel',WB_options);
xtickangle(35);
title(sprintf('Relative Residual, log10-scale (%s), s = %d', matnum, s));

% Write log10 values inside the cells
vmin_rel = min(R(:)); 
vmax_rel = max(R(:)); 
thr_rel = (vmin_rel + vmax_rel)/2;
[m,n] = size(R);
for i = 1:m
  for j = 1:n
    val_rel = R(i,j);
    txt_rel = sprintf('%.2f', val_rel);      
    clr = 'w'; if val_rel > thr_rel, clr='k'; end
    text(j,i,txt_rel, 'Color',clr, 'FontWeight','bold',...
         'HorizontalAlignment','center','VerticalAlignment','middle');
  end
end
axis tight;

% plot for orthErr
O = log10(orthErr);                

figure;
imagesc(O);  
colormap(parula);
caxis([-16 0]); 
colorbar;

set(gca,'XTick',1:length(AOB_options),'XTickLabel',AOB_options);
set(gca,'YTick',1:length(WB_options),'YTickLabel',WB_options);
xtickangle(35);
title(sprintf('Loss of Orthogonality, log10-scale (%s), s = %d', matnum, s));

% Write log10 values inside the cells
vmin_orth = min(O(:)); 
vmax_orth = max(O(:)); 
thr_orth = (vmin_orth + vmax_orth)/2;
for i = 1:m
  for j = 1:n
    val_orth = O(i,j);
    txt_orth = sprintf('%.2f', val_orth);      
    clr = 'w'; if val_orth > thr_orth, clr='k'; end
    text(j,i,txt_orth, 'Color',clr, 'FontWeight','bold',...
         'HorizontalAlignment','center','VerticalAlignment','middle');
  end
end
axis tight;
%}

relErr_log = log10(relErr);
orthErr_log = log10(orthErr);
plot_heatmap(relErr_log, "Relative Residual", WB_options, AOB_options, ss, matnum);
plot_heatmap(orthErr_log, "Loss of Orthogonality", WB_options, AOB_options, ss, matnum);
plot_heatmap(idx_ls, "Index", WB_options, AOB_options, ss, matnum);
cond_log = log10(cond_ls);
plot_heatmap(cond_log, "Condition number", WB_options, AOB_options, ss, matnum);
sol_log = log10(sol_ls);
plot_heatmap(sol_log, "Relative error", WB_options, AOB_options, ss, matnum);