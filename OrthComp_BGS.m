%rng(0);
% load the matrix
% matrix from SuiteSparse
matnum = 'SiH4';
S = load([matnum '.mat']);
matrix = S.Problem.A;
n = size(matrix, 1);
% convert to function handle
A = @(x) matrix * x;

% matrix generated by function 'getStartMatrix'
%n = 5000;
%alpha = 0;
%matrix = getStartMatrix(n, alpha);
%matnum = 'genMatrix(1e3)';
%A = matrix;

% step size
ss = 5:5:40;
l = length(ss);

ctol = 1e-16;

% AOB_options for BGS
AOB_options = ["CGS2", "CGS", "MGS"];
% WB_options for RBGS
WB_options = ["CGS", "CGS2", "MGS", "Householder"];

relResAll   = cell(length(WB_options),length(AOB_options), l);
orthLossAll = cell(length(WB_options),length(AOB_options), l);
for vs = 1:l
    s = ss(vs);
    p = round(500/s);
    m = p * s + 1;
    d = 2 * m;
    % Newton Basis
    RitzValues = getRitzValues(A, ritz, s);
    basisFunc = @(Afun, q, s) mpk(Afun, q, s, RitzValues);
    % Monomial Basis    
    %basisFunc = @mpk;
    for aob = 1:length(AOB_options)
        for wb = 1:length(WB_options)
            % orthogonalized methods for RBGS
            orth_option = [aob, wb];
            AOB = AOB_options(orth_option(1));
            WB = WB_options(orth_option(2));
            fprintf('Starting AOB = %s, WB = %s, s = %d \n', AOB, WB, s);
            [~, relRes, orthLoss] = BGS_GMRES0(A, s, p, basisFunc, ...
                AOB, WB, b, ctol);            
            relResAll{wb, aob, vs}   = relRes;
            orthLossAll{wb, aob, vs} = orthLoss;
        end
    end
end