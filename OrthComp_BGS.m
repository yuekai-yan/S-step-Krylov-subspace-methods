% load the matrix
% matrix from SuiteSparse
matnum = 'SiH4';
S = load([matnum '.mat']);
matrix = S.Problem.A;
n = size(matrix, 1);
% convert to function handle
A = @(x) matrix * x;

% matrix generated by function 'getStartMatrix'
%n = 2500;
%alpha = 0.5;
%matrix = getStartMatrix(n, alpha);
%matnum = 'genMatrix(1e-3)';
%A = matrix;

% set the basic parameters
t = randn(n,1);
b = A(t);
% step size
ss = 5:5:40;
l = length(ss);

ctol = 1e-16;
runs = 1;

% define AOB_options for BGS
AOB_options = ["CGS2", "CGS", "GS", "MGS"];
% define WB_options for RBGS
WB_options = ["CGS", "CGS2", "GS", "MGS", "Whitening"];

relRes = zeros(length(WB_options),length(AOB_options), l);
orthLoss = zeros(length(WB_options),length(AOB_options), l);
idx_ls = zeros(length(WB_options),length(AOB_options), l);
cond_ls = zeros(length(WB_options),length(AOB_options), l);
sol_ls = zeros(length(WB_options),length(AOB_options), l);

for vs = 1:l
    s = ss(vs);
    p = round(500/s);
    m = p * s + 1;
    d = 2 * m;
    % Newton Basis
    rng(0);
    RitzValues = getRitzValues(A, randn(n, 1), s);
    basisFunc = @(Afun, q, s) mpk(Afun, q, s, RitzValues);
    % Monomial Basis    
    %basisFunc = @mpk;
    for aob = 1:length(AOB_options)
        for wb = 1:length(WB_options)
            % orthogonalized methods for BGS
            orth_option = [aob, wb];
            AOB = AOB_options(orth_option(1));
            WB = WB_options(orth_option(2));
            fprintf('Starting AOB = %s, WB = %s, s = %d \n', AOB, WB, s);

            [sol, relRes0, orthLoss0] = BGS_GMRES0(A, s, p, basisFunc, ...
                AOB, WB, b, ctol);            
             
            % use elbow point detection instead of min(relRes)
            y = log10(relRes0(:));               
            valid = isfinite(y);  % remove NaN or Inf entries
            x = (1:numel(y))';
            x = x(valid);  
            y = y(valid);        
            % line through the first and last points
            p1 = [x(1), y(1)]; 
            p2 = [x(end), y(end)];        
            % perpendicular distance to the endpoint line
            dist = abs((p2(2)-p1(2))*x - (p2(1)-p1(1))*y + p2(1)*p1(2) - p2(2)*p1(1)) ...
                   / hypot(p2(2)-p1(2), p2(1)-p1(1));

            % record relRes and orthLoss at the elbow point
            [~, idx] = max(dist);
            %[~, idx] = min(relRes);
            relRes(wb, aob, vs)  = relRes0(idx);
            orthLoss(wb, aob, vs) = orthLoss0(idx);
            idx_ls(wb, aob, vs) = idx * s;
            %cond_ls(wb, aob, vs) = cond_num(idx);
            sol_ls(wb, aob, vs) = norm(sol(:, idx)-t) / norm(t);
        end
    end
end

% ---------- plot ----------
relRes_log = log10(relRes);
orthLoss_log = log10(orthLoss);
plot_heatmap(relRes_log, "Relative Residual", WB_options, AOB_options, ss, matnum);
plot_heatmap(orthLoss_log, "Loss of Orthogonality", WB_options, AOB_options, ss, matnum);

plot_heatmap(idx_ls, "Index", WB_options, AOB_options, ss, matnum);

%cond_log = log10(cond_ls);
%plot_heatmap(cond_log, "Condition number", WB_options, AOB_options, ss, matnum);

sol_log = log10(sol_ls);
plot_heatmap(sol_log, "Relative error", WB_options, AOB_options, ss, matnum);